# Backend Security Standards

This document provides comprehensive security standards for backend development in UI-base projects. All backend services must follow these standards to ensure robust security posture.

## Table of Contents

- [OWASP Top 10 Compliance](#owasp-top-10-compliance)
- [Authentication and Authorization](#authentication-and-authorization)
- [Input Validation and Sanitization](#input-validation-and-sanitization)
- [Security Headers Configuration](#security-headers-configuration)
- [Rate Limiting and DDoS Protection](#rate-limiting-and-ddos-protection)
- [Secret Management](#secret-management)
- [Data Encryption](#data-encryption)
- [Logging and Monitoring](#logging-and-monitoring)
- [Error Handling](#error-handling)
- [API Security](#api-security)
- [Database Security](#database-security)
- [Session Management](#session-management)
- [File Upload Security](#file-upload-security)
- [Third-Party Dependencies](#third-party-dependencies)
- [Security Testing](#security-testing)

## OWASP Top 10 Compliance

All applications must address the OWASP Top 10 security risks:

### 1. Broken Access Control (A01:2021)

**Requirements:**
- Implement proper authorization checks for all endpoints
- Use role-based access control (RBAC) or attribute-based access control (ABAC)
- Deny access by default, grant explicitly
- Log all access control failures

**Implementation:**
```javascript
// Express middleware example
const authorize = (requiredRole) => {
  return async (req, res, next) => {
    try {
      const user = req.user;
      if (!user || !user.roles.includes(requiredRole)) {
        logger.warn('Authorization failed', { 
          userId: user?.id, 
          requiredRole,
          endpoint: req.path 
        });
        return res.status(403).json({ error: 'Forbidden' });
      }
      next();
    } catch (error) {
      logger.error('Authorization error', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  };
};

// Usage
app.get('/admin/users', authenticate, authorize('admin'), getUsers);
```

### 2. Cryptographic Failures (A02:2021)

**Requirements:**
- Use strong encryption for sensitive data at rest and in transit
- Never store passwords in plain text
- Use bcrypt with cost factor of 12 or higher for password hashing
- Implement proper key management

**Implementation:**
```javascript
const bcrypt = require('bcrypt');
const crypto = require('crypto');

// Password hashing
const hashPassword = async (password) => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

// Data encryption
const encrypt = (text, secretKey) => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-gcm', secretKey, iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex')
  };
};
```

### 3. Injection (A03:2021)

**Requirements:**
- Use parameterized queries for all database operations
- Validate and sanitize all user inputs
- Never concatenate user input into queries
- Use ORM/query builders with built-in protection

**Implementation:**
```javascript
// Good: Parameterized query
const getUserById = async (userId) => {
  const query = 'SELECT * FROM users WHERE id = $1';
  const values = [userId];
  return await db.query(query, values);
};

// Good: Using ORM (Sequelize example)
const user = await User.findOne({
  where: {
    id: userId,
    status: 'active'
  }
});

// Bad: Never do this!
// const query = `SELECT * FROM users WHERE id = ${userId}`;
```

### 4. Insecure Design (A04:2021)

**Requirements:**
- Implement threat modeling during design phase
- Follow security design patterns
- Implement defense in depth
- Regular security architecture reviews

**Best Practices:**
- Separate concerns (authentication, authorization, business logic)
- Use secure design patterns (Factory, Proxy for access control)
- Implement fail-safe defaults
- Minimize attack surface

### 5. Security Misconfiguration (A05:2021)

**Requirements:**
- Disable unnecessary features and services
- Configure secure defaults
- Keep all software updated
- Remove default accounts and passwords
- Implement proper error handling

**Implementation:**
```javascript
// Security configuration example
const helmet = require('helmet');
const app = express();

// Apply security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// Disable X-Powered-By header
app.disable('x-powered-by');

// Set secure cookie options
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true, // HTTPS only
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24, // 24 hours
    sameSite: 'strict'
  }
}));
```

### 6. Vulnerable and Outdated Components (A06:2021)

**Requirements:**
- Regular dependency updates
- Automated vulnerability scanning
- Component inventory management
- Remove unused dependencies

**Implementation:**
```json
// package.json scripts
{
  "scripts": {
    "audit": "npm audit --audit-level=moderate",
    "audit:fix": "npm audit fix",
    "outdated": "npm outdated",
    "deps:check": "depcheck",
    "security:check": "snyk test"
  }
}
```

### 7. Identification and Authentication Failures (A07:2021)

**Requirements:**
- Implement multi-factor authentication (MFA)
- Strong password policies
- Account lockout mechanisms
- Secure session management

**Implementation:**
```javascript
const speakeasy = require('speakeasy');

// Generate MFA secret
const generateMFASecret = (user) => {
  const secret = speakeasy.generateSecret({
    name: `YourApp (${user.email})`
  });
  return secret;
};

// Verify MFA token
const verifyMFAToken = (secret, token) => {
  return speakeasy.totp.verify({
    secret: secret.base32,
    encoding: 'base32',
    token: token,
    window: 2
  });
};

// Account lockout
const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_TIME = 15 * 60 * 1000; // 15 minutes

const checkAccountLockout = async (email) => {
  const attempts = await getLoginAttempts(email);
  if (attempts >= MAX_LOGIN_ATTEMPTS) {
    const lastAttempt = await getLastAttemptTime(email);
    if (Date.now() - lastAttempt < LOCKOUT_TIME) {
      throw new Error('Account temporarily locked');
    }
    await resetLoginAttempts(email);
  }
};
```

### 8. Software and Data Integrity Failures (A08:2021)

**Requirements:**
- Verify software integrity
- Implement code signing
- Secure CI/CD pipeline
- Input validation for serialized data

**Implementation:**
```javascript
const crypto = require('crypto');

// Verify file integrity
const verifyIntegrity = (data, expectedHash) => {
  const hash = crypto.createHash('sha256').update(data).digest('hex');
  return hash === expectedHash;
};

// Secure deserialization
const safeJsonParse = (jsonString) => {
  try {
    const parsed = JSON.parse(jsonString);
    // Additional validation
    if (typeof parsed !== 'object' || parsed === null) {
      throw new Error('Invalid JSON structure');
    }
    return parsed;
  } catch (error) {
    logger.error('JSON parsing error', error);
    throw new Error('Invalid data format');
  }
};
```

### 9. Security Logging and Monitoring Failures (A09:2021)

**Requirements:**
- Log all security events
- Protect log integrity
- Real-time alerting for critical events
- Log retention policies

**Implementation:**
```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: { service: 'api' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.File({ filename: 'security.log', level: 'warn' })
  ]
});

// Security event logging
const logSecurityEvent = (event, metadata) => {
  logger.warn('Security Event', {
    event,
    timestamp: new Date().toISOString(),
    ...metadata
  });
};

// Usage examples
logSecurityEvent('LOGIN_FAILED', { email, ip: req.ip });
logSecurityEvent('UNAUTHORIZED_ACCESS', { userId, resource, ip: req.ip });
logSecurityEvent('RATE_LIMIT_EXCEEDED', { ip: req.ip, endpoint: req.path });
```

### 10. Server-Side Request Forgery (SSRF) (A10:2021)

**Requirements:**
- Validate and sanitize URLs
- Whitelist allowed domains
- Use allowlists for internal resources
- Disable unnecessary URL schemes

**Implementation:**
```javascript
const { URL } = require('url');

const ALLOWED_DOMAINS = [
  'api.trusted-service.com',
  'cdn.trusted-service.com'
];

const validateUrl = (urlString) => {
  try {
    const url = new URL(urlString);
    
    // Check protocol
    if (!['http:', 'https:'].includes(url.protocol)) {
      throw new Error('Invalid protocol');
    }
    
    // Check domain whitelist
    if (!ALLOWED_DOMAINS.includes(url.hostname)) {
      throw new Error('Domain not allowed');
    }
    
    // Prevent local network access
    const localPatterns = [
      /^localhost$/i,
      /^127\./,
      /^10\./,
      /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
      /^192\.168\./
    ];
    
    if (localPatterns.some(pattern => pattern.test(url.hostname))) {
      throw new Error('Local network access not allowed');
    }
    
    return url;
  } catch (error) {
    throw new Error(`Invalid URL: ${error.message}`);
  }
};
```

## Authentication and Authorization

### JWT Implementation

```javascript
const jwt = require('jsonwebtoken');

const generateTokens = (userId) => {
  const accessToken = jwt.sign(
    { userId, type: 'access' },
    process.env.JWT_ACCESS_SECRET,
    { expiresIn: '15m' }
  );
  
  const refreshToken = jwt.sign(
    { userId, type: 'refresh' },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: '7d' }
  );
  
  return { accessToken, refreshToken };
};

const verifyToken = (token, secret) => {
  try {
    return jwt.verify(token, secret);
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      throw new Error('Token expired');
    }
    throw new Error('Invalid token');
  }
};
```

### OAuth 2.0 Implementation

```javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
  try {
    let user = await User.findOne({ googleId: profile.id });
    
    if (!user) {
      user = await User.create({
        googleId: profile.id,
        email: profile.emails[0].value,
        name: profile.displayName
      });
    }
    
    return done(null, user);
  } catch (error) {
    return done(error, null);
  }
}));
```

## Input Validation and Sanitization

### Using Joi for Validation

```javascript
const Joi = require('joi');

const userSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).required(),
  name: Joi.string().min(2).max(100).required(),
  age: Joi.number().integer().min(13).max(120),
  role: Joi.string().valid('user', 'admin', 'moderator').default('user')
});

const validateUser = (req, res, next) => {
  const { error, value } = userSchema.validate(req.body, {
    abortEarly: false,
    stripUnknown: true
  });
  
  if (error) {
    const errors = error.details.map(detail => ({
      field: detail.path.join('.'),
      message: detail.message
    }));
    return res.status(400).json({ errors });
  }
  
  req.validatedBody = value;
  next();
};
```

### Input Sanitization

```javascript
const validator = require('validator');
const DOMPurify = require('isomorphic-dompurify');

const sanitizeInput = (input) => {
  // Remove HTML tags and scripts
  let sanitized = DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
  
  // Escape special characters
  sanitized = validator.escape(sanitized);
  
  // Trim whitespace
  sanitized = sanitized.trim();
  
  return sanitized;
};

// SQL injection prevention helper
const sanitizeSqlIdentifier = (identifier) => {
  // Only allow alphanumeric and underscore
  if (!/^[a-zA-Z0-9_]+$/.test(identifier)) {
    throw new Error('Invalid identifier');
  }
  return identifier;
};
```

## Security Headers Configuration

### Helmet.js Configuration

```javascript
const helmet = require('helmet');

app.use(helmet({
  // Content Security Policy
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      scriptSrc: ["'self'", "https://www.google-analytics.com"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      upgradeInsecureRequests: []
    },
  },
  
  // Strict-Transport-Security
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  
  // X-Frame-Options
  frameguard: {
    action: 'deny'
  },
  
  // X-Content-Type-Options
  noSniff: true,
  
  // X-XSS-Protection
  xssFilter: true,
  
  // Referrer-Policy
  referrerPolicy: {
    policy: 'strict-origin-when-cross-origin'
  },
  
  // Permissions-Policy
  permittedCrossDomainPolicies: false
}));

// Additional custom headers
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
  next();
});
```

## Rate Limiting and DDoS Protection

### Express Rate Limit

```javascript
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const Redis = require('ioredis');

const redisClient = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// General API rate limit
const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:api:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn('Rate limit exceeded', { ip: req.ip, path: req.path });
    res.status(429).json({
      error: 'Too many requests',
      retryAfter: req.rateLimit.resetTime
    });
  }
});

// Strict rate limit for auth endpoints
const authLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:auth:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  skipSuccessfulRequests: true
});

// Apply rate limiters
app.use('/api/', apiLimiter);
app.use('/auth/', authLimiter);
```

### Advanced DDoS Protection

```javascript
const SlowDown = require('express-slow-down');

// Progressive delay for repeated requests
const speedLimiter = SlowDown({
  windowMs: 15 * 60 * 1000,
  delayAfter: 50,
  delayMs: 500,
  maxDelayMs: 20000
});

// Request size limiting
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ limit: '10mb', extended: true }));

// Connection limiting
const server = app.listen(port, () => {
  server.maxConnections = 1000;
  server.timeout = 30000; // 30 seconds
  server.keepAliveTimeout = 65000; // 65 seconds
});
```

## Secret Management

### Environment Variables

```javascript
const dotenv = require('dotenv');
const fs = require('fs');
const path = require('path');

// Load environment-specific config
const envFile = process.env.NODE_ENV === 'production' 
  ? '.env.production' 
  : '.env.development';

if (fs.existsSync(path.join(__dirname, envFile))) {
  dotenv.config({ path: envFile });
}

// Validate required environment variables
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_ACCESS_SECRET',
  'JWT_REFRESH_SECRET',
  'SESSION_SECRET',
  'ENCRYPTION_KEY'
];

requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
});
```

### AWS Secrets Manager Integration

```javascript
const AWS = require('aws-sdk');

const secretsManager = new AWS.SecretsManager({
  region: process.env.AWS_REGION
});

const getSecret = async (secretName) => {
  try {
    const data = await secretsManager.getSecretValue({ 
      SecretId: secretName 
    }).promise();
    
    if ('SecretString' in data) {
      return JSON.parse(data.SecretString);
    }
    
    const buff = Buffer.from(data.SecretBinary, 'base64');
    return JSON.parse(buff.toString('ascii'));
  } catch (error) {
    logger.error('Failed to retrieve secret', { secretName, error });
    throw error;
  }
};

// Usage
const dbCredentials = await getSecret('prod/database/credentials');
```

### Vault Integration

```javascript
const vault = require('node-vault')({
  apiVersion: 'v1',
  endpoint: process.env.VAULT_ADDR,
  token: process.env.VAULT_TOKEN
});

const getVaultSecret = async (path) => {
  try {
    const response = await vault.read(path);
    return response.data;
  } catch (error) {
    logger.error('Failed to read from Vault', { path, error });
    throw error;
  }
};
```

## Data Encryption

### Encryption at Rest

```javascript
const crypto = require('crypto');

class Encryption {
  constructor(key) {
    this.algorithm = 'aes-256-gcm';
    this.key = Buffer.from(key, 'hex');
  }
  
  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }
  
  decrypt(encryptedData) {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      this.key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

const encryption = new Encryption(process.env.ENCRYPTION_KEY);
```

### Field-Level Encryption

```javascript
// Mongoose schema with encrypted fields
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  ssn: {
    type: String,
    get: decrypt,
    set: encrypt
  },
  creditCard: {
    type: String,
    get: decrypt,
    set: encrypt
  }
});

function encrypt(value) {
  if (!value) return value;
  const encrypted = encryption.encrypt(value);
  return JSON.stringify(encrypted);
}

function decrypt(value) {
  if (!value) return value;
  try {
    const encryptedData = JSON.parse(value);
    return encryption.decrypt(encryptedData);
  } catch (error) {
    logger.error('Decryption failed', error);
    return null;
  }
}
```

## Logging and Monitoring

### Structured Logging

```javascript
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'api',
    environment: process.env.NODE_ENV
  },
  transports: [
    // Console transport for development
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // File transports
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    // Elasticsearch transport for production
    new ElasticsearchTransport({
      level: 'info',
      clientOpts: {
        node: process.env.ELASTICSEARCH_URL,
        auth: {
          username: process.env.ELASTICSEARCH_USER,
          password: process.env.ELASTICSEARCH_PASSWORD
        }
      },
      index: 'logs-api'
    })
  ]
});

// Request logging middleware
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      userId: req.user?.id
    });
  });
  
  next();
});
```

### Security Event Monitoring

```javascript
class SecurityMonitor {
  constructor() {
    this.thresholds = {
      failedLogins: 5,
      rateLimitHits: 10,
      unauthorizedAccess: 3
    };
    this.timeWindow = 15 * 60 * 1000; // 15 minutes
  }
  
  async trackEvent(eventType, metadata) {
    const key = `security:${eventType}:${metadata.identifier}`;
    const count = await redis.incr(key);
    
    if (count === 1) {
      await redis.expire(key, this.timeWindow / 1000);
    }
    
    if (count >= this.thresholds[eventType]) {
      await this.triggerAlert(eventType, metadata, count);
    }
    
    logger.warn('Security Event', {
      eventType,
      count,
      ...metadata
    });
  }
  
  async triggerAlert(eventType, metadata, count) {
    // Send alert to security team
    await sendSecurityAlert({
      type: eventType,
      severity: 'high',
      count,
      metadata,
      timestamp: new Date().toISOString()
    });
    
    // Take automated action if configured
    if (eventType === 'failedLogins') {
      await this.blockIP(metadata.ip);
    }
  }
  
  async blockIP(ip) {
    await redis.setex(`blocked:ip:${ip}`, 3600, 'true'); // 1 hour block
    logger.warn('IP blocked due to suspicious activity', { ip });
  }
}

const securityMonitor = new SecurityMonitor();
```

## Error Handling

### Secure Error Responses

```javascript
class AppError extends Error {
  constructor(message, statusCode, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }
}

// Global error handler
app.use((err, req, res, next) => {
  let { statusCode = 500, message, isOperational } = err;
  
  // Log error details
  logger.error('Error occurred', {
    error: err,
    request: {
      method: req.method,
      url: req.url,
      ip: req.ip,
      userId: req.user?.id
    },
    stack: err.stack
  });
  
  // Don't leak error details in production
  if (process.env.NODE_ENV === 'production' && !isOperational) {
    statusCode = 500;
    message = 'Internal server error';
  }
  
  res.status(statusCode).json({
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Resource not found' });
});
```

## API Security

### API Versioning

```javascript
const router = express.Router();

// Version 1 routes
app.use('/api/v1', require('./routes/v1'));

// Version 2 routes with breaking changes
app.use('/api/v2', require('./routes/v2'));

// Deprecation headers for old versions
app.use('/api/v1', (req, res, next) => {
  res.set('Sunset', 'Sat, 31 Dec 2025 23:59:59 GMT');
  res.set('Deprecation', 'true');
  res.set('Link', '</api/v2>; rel="successor-version"');
  next();
});
```

### API Key Authentication

```javascript
const apiKeyAuth = async (req, res, next) => {
  const apiKey = req.headers['x-api-key'] || req.query.api_key;
  
  if (!apiKey) {
    return res.status(401).json({ error: 'API key required' });
  }
  
  try {
    // Hash the API key before database lookup
    const hashedKey = crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');
    
    const keyRecord = await ApiKey.findOne({ 
      hashedKey,
      active: true
    });
    
    if (!keyRecord) {
      logger.warn('Invalid API key attempt', { ip: req.ip });
      return res.status(401).json({ error: 'Invalid API key' });
    }
    
    // Check rate limits for this API key
    const usage = await incrementApiKeyUsage(keyRecord.id);
    if (usage > keyRecord.rateLimit) {
      return res.status(429).json({ error: 'Rate limit exceeded' });
    }
    
    req.apiKey = keyRecord;
    next();
  } catch (error) {
    logger.error('API key authentication error', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
};
```

## Database Security

### Connection Security

```javascript
const mongoose = require('mongoose');

const mongoOptions = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  authSource: 'admin',
  ssl: true,
  sslValidate: true,
  sslCA: fs.readFileSync(path.join(__dirname, 'certs/ca.pem')),
  sslCert: fs.readFileSync(path.join(__dirname, 'certs/client-cert.pem')),
  sslKey: fs.readFileSync(path.join(__dirname, 'certs/client-key.pem')),
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
};

mongoose.connect(process.env.MONGODB_URI, mongoOptions);
```

### Query Security

```javascript
// Prevent NoSQL injection
const sanitizeQuery = (query) => {
  const cleaned = {};
  for (const key in query) {
    if (typeof query[key] === 'string') {
      cleaned[key] = query[key];
    } else if (typeof query[key] === 'number') {
      cleaned[key] = query[key];
    } else if (Array.isArray(query[key])) {
      cleaned[key] = query[key].filter(item => 
        typeof item === 'string' || typeof item === 'number'
      );
    }
    // Ignore objects to prevent operator injection
  }
  return cleaned;
};

// Safe query execution
const findUsers = async (filters) => {
  const sanitized = sanitizeQuery(filters);
  return await User.find(sanitized).limit(100);
};
```

## Session Management

### Secure Session Configuration

```javascript
const session = require('express-session');
const MongoStore = require('connect-mongo');

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId', // Don't use default name
  resave: false,
  saveUninitialized: false,
  rolling: true, // Reset expiry on activity
  cookie: {
    secure: true, // HTTPS only
    httpOnly: true, // No JavaScript access
    maxAge: 1000 * 60 * 60 * 2, // 2 hours
    sameSite: 'strict' // CSRF protection
  },
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URI,
    crypto: {
      secret: process.env.SESSION_STORE_SECRET
    },
    autoRemove: 'interval',
    autoRemoveInterval: 10 // minutes
  })
}));

// Session invalidation on logout
app.post('/logout', (req, res) => {
  const sessionId = req.sessionID;
  req.session.destroy((err) => {
    if (err) {
      logger.error('Session destruction failed', { sessionId, error: err });
      return res.status(500).json({ error: 'Logout failed' });
    }
    res.clearCookie('sessionId');
    logger.info('User logged out', { sessionId, userId: req.user?.id });
    res.json({ message: 'Logged out successfully' });
  });
});
```

## File Upload Security

### Secure File Upload

```javascript
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

// File type validation
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Invalid file type'));
  }
};

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueName = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname);
    cb(null, `${uniqueName}${ext}`);
  }
});

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5 // Max 5 files
  }
});

// Virus scanning integration
const scanFile = async (filepath) => {
  // Integration with ClamAV or similar
  const result = await virusScanner.scanFile(filepath);
  if (result.infected) {
    await fs.promises.unlink(filepath);
    throw new Error('Malicious file detected');
  }
};

// Upload endpoint
app.post('/upload', authenticate, upload.single('file'), async (req, res) => {
  try {
    // Scan for viruses
    await scanFile(req.file.path);
    
    // Store file metadata in database
    const fileRecord = await File.create({
      originalName: req.file.originalname,
      filename: req.file.filename,
      mimetype: req.file.mimetype,
      size: req.file.size,
      uploadedBy: req.user.id,
      uploadedAt: new Date()
    });
    
    res.json({ file: fileRecord });
  } catch (error) {
    // Clean up file on error
    if (req.file) {
      await fs.promises.unlink(req.file.path).catch(() => {});
    }
    logger.error('File upload failed', error);
    res.status(400).json({ error: error.message });
  }
});
```

## Third-Party Dependencies

### Dependency Security

```javascript
// package.json
{
  "scripts": {
    "preinstall": "npm audit",
    "postinstall": "npm run security:check",
    "security:check": "npm audit --production && snyk test",
    "security:monitor": "snyk monitor",
    "deps:outdated": "npm outdated",
    "deps:update": "npm update && npm audit fix",
    "deps:check-unused": "depcheck"
  },
  "devDependencies": {
    "snyk": "^1.1064.0",
    "depcheck": "^1.4.3",
    "npm-audit-resolver": "^3.0.0"
  }
}
```

### Supply Chain Security

```javascript
// .npmrc
save-exact=true
package-lock=true
audit-level=moderate
fund=false

// CI/CD pipeline check
const checkDependencies = async () => {
  const { exec } = require('child_process');
  const util = require('util');
  const execPromise = util.promisify(exec);
  
  try {
    // Check for known vulnerabilities
    const { stdout: auditResult } = await execPromise('npm audit --json');
    const audit = JSON.parse(auditResult);
    
    if (audit.metadata.vulnerabilities.high > 0 || 
        audit.metadata.vulnerabilities.critical > 0) {
      throw new Error('High or critical vulnerabilities found');
    }
    
    // Check licenses
    const { stdout: licenses } = await execPromise('license-checker --json');
    const licenseData = JSON.parse(licenses);
    
    const prohibitedLicenses = ['GPL', 'AGPL'];
    for (const [pkg, info] of Object.entries(licenseData)) {
      if (prohibitedLicenses.some(l => info.licenses?.includes(l))) {
        throw new Error(`Prohibited license in ${pkg}: ${info.licenses}`);
      }
    }
  } catch (error) {
    console.error('Dependency check failed:', error);
    process.exit(1);
  }
};
```

## Security Testing

### Automated Security Tests

```javascript
// security.test.js
const request = require('supertest');
const app = require('../app');

describe('Security Tests', () => {
  describe('Headers', () => {
    it('should set security headers', async () => {
      const response = await request(app).get('/');
      
      expect(response.headers['x-content-type-options']).toBe('nosniff');
      expect(response.headers['x-frame-options']).toBe('DENY');
      expect(response.headers['x-xss-protection']).toBe('1; mode=block');
      expect(response.headers['strict-transport-security']).toMatch(/max-age=/);
      expect(response.headers['x-powered-by']).toBeUndefined();
    });
  });
  
  describe('Input Validation', () => {
    it('should reject SQL injection attempts', async () => {
      const response = await request(app)
        .get('/api/users')
        .query({ id: "1' OR '1'='1" });
      
      expect(response.status).toBe(400);
      expect(response.body.error).toMatch(/Invalid/);
    });
    
    it('should reject XSS attempts', async () => {
      const response = await request(app)
        .post('/api/comments')
        .send({ text: '<script>alert("XSS")</script>' });
      
      expect(response.status).toBe(400);
      expect(response.body.error).toMatch(/Invalid/);
    });
  });
  
  describe('Authentication', () => {
    it('should reject requests without authentication', async () => {
      const response = await request(app).get('/api/protected');
      expect(response.status).toBe(401);
    });
    
    it('should enforce rate limiting on auth endpoints', async () => {
      const attempts = Array(6).fill(null).map(() => 
        request(app)
          .post('/auth/login')
          .send({ email: 'test@test.com', password: 'wrong' })
      );
      
      const responses = await Promise.all(attempts);
      const lastResponse = responses[responses.length - 1];
      
      expect(lastResponse.status).toBe(429);
    });
  });
});
```

### Penetration Testing Checklist

```markdown
## API Security Testing Checklist

### Authentication Tests
- [ ] Test with expired tokens
- [ ] Test with malformed tokens
- [ ] Test token replay attacks
- [ ] Test concurrent sessions
- [ ] Test session fixation
- [ ] Test password reset flow

### Authorization Tests
- [ ] Test horizontal privilege escalation
- [ ] Test vertical privilege escalation
- [ ] Test accessing other users' resources
- [ ] Test modifying other users' data
- [ ] Test admin endpoints as regular user

### Input Validation Tests
- [ ] Test SQL injection on all parameters
- [ ] Test NoSQL injection
- [ ] Test XSS in all input fields
- [ ] Test XXE injection
- [ ] Test command injection
- [ ] Test path traversal
- [ ] Test file upload exploits

### Business Logic Tests
- [ ] Test race conditions
- [ ] Test workflow bypass
- [ ] Test price manipulation
- [ ] Test quantity limits
- [ ] Test time-based restrictions

### API Specific Tests
- [ ] Test rate limiting bypass
- [ ] Test API versioning
- [ ] Test CORS configuration
- [ ] Test HTTP method tampering
- [ ] Test content-type validation
```

## Security Monitoring Dashboard

```javascript
// Real-time security metrics
const securityMetrics = {
  async getMetrics() {
    const [
      failedLogins,
      rateLimitHits,
      blockedIPs,
      suspiciousRequests
    ] = await Promise.all([
      redis.get('metrics:failed_logins:count'),
      redis.get('metrics:rate_limit:count'),
      redis.scard('blocked:ips'),
      redis.get('metrics:suspicious:count')
    ]);
    
    return {
      failedLogins: parseInt(failedLogins) || 0,
      rateLimitHits: parseInt(rateLimitHits) || 0,
      blockedIPs: blockedIPs || 0,
      suspiciousRequests: parseInt(suspiciousRequests) || 0,
      timestamp: new Date().toISOString()
    };
  },
  
  async getAlerts(hours = 24) {
    const since = Date.now() - (hours * 60 * 60 * 1000);
    const alerts = await SecurityAlert.find({
      createdAt: { $gte: new Date(since) }
    }).sort({ createdAt: -1 });
    
    return alerts;
  }
};

// Expose metrics endpoint (protected)
app.get('/api/admin/security/metrics', 
  authenticate, 
  authorize('admin'), 
  async (req, res) => {
    const metrics = await securityMetrics.getMetrics();
    const alerts = await securityMetrics.getAlerts();
    
    res.json({ metrics, alerts });
  }
);
```

## Compliance and Audit

### Audit Trail

```javascript
const auditLog = {
  async log(action, metadata) {
    await AuditLog.create({
      action,
      userId: metadata.userId,
      ip: metadata.ip,
      userAgent: metadata.userAgent,
      resource: metadata.resource,
      changes: metadata.changes,
      timestamp: new Date()
    });
  },
  
  async getAuditTrail(filters = {}) {
    const query = {};
    
    if (filters.userId) query.userId = filters.userId;
    if (filters.action) query.action = filters.action;
    if (filters.startDate && filters.endDate) {
      query.timestamp = {
        $gte: new Date(filters.startDate),
        $lte: new Date(filters.endDate)
      };
    }
    
    return await AuditLog.find(query)
      .sort({ timestamp: -1 })
      .limit(filters.limit || 100);
  }
};

// Audit middleware
const auditMiddleware = (action) => {
  return async (req, res, next) => {
    const originalSend = res.send;
    
    res.send = function(data) {
      res.send = originalSend;
      
      if (res.statusCode < 400) {
        auditLog.log(action, {
          userId: req.user?.id,
          ip: req.ip,
          userAgent: req.get('user-agent'),
          resource: req.path,
          method: req.method,
          body: req.body
        }).catch(err => logger.error('Audit log failed', err));
      }
      
      return res.send(data);
    };
    
    next();
  };
};
```

## Security Best Practices Summary

1. **Defense in Depth**: Implement multiple layers of security
2. **Principle of Least Privilege**: Grant minimum necessary access
3. **Fail Securely**: Default to denying access
4. **Don't Trust User Input**: Validate and sanitize everything
5. **Keep Security Simple**: Complex systems are harder to secure
6. **Fix Security Issues Correctly**: Address root causes, not symptoms
7. **Use Secure Defaults**: Make the secure choice the easy choice
8. **Regular Security Updates**: Keep all dependencies updated
9. **Monitor and Log**: Track security events and anomalies
10. **Regular Security Testing**: Automated and manual testing

## Resources

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)
- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CWE/SANS Top 25](https://cwe.mitre.org/top25/)