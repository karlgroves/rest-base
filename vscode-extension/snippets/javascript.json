{
  "REST Express Controller": {
    "prefix": "rest-controller",
    "body": [
      "/**",
      " * ${1:ModelName} Controller",
      " * ",
      " * Handles HTTP requests for ${1:ModelName} resources",
      " * @author ${2:Author}",
      " */",
      "",
      "const { ${1:ModelName} } = require('../models');",
      "const { ValidationError, NotFoundError } = require('../utils/errors');",
      "const logger = require('../utils/logger');",
      "",
      "/**",
      " * Get all ${1/(.*)/${1:/downcase}/} records",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const getAll${1:ModelName}s = async (req, res, next) => {",
      "  try {",
      "    const { page = 1, limit = 10, sort = 'createdAt', order = 'DESC' } = req.query;",
      "    ",
      "    const offset = (page - 1) * limit;",
      "    ",
      "    const { rows: ${1/(.*)/${1:/downcase}/}s, count } = await ${1:ModelName}.findAndCountAll({",
      "      offset: parseInt(offset),",
      "      limit: parseInt(limit),",
      "      order: [[sort, order.toUpperCase()]]",
      "    });",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}s,",
      "      pagination: {",
      "        page: parseInt(page),",
      "        limit: parseInt(limit),",
      "        total: count,",
      "        totalPages: Math.ceil(count / limit)",
      "      }",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error fetching ${1/(.*)/${1:/downcase}/}s:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Get ${1/(.*)/${1:/downcase}/} by ID",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const get${1:ModelName}ById = async (req, res, next) => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const ${1/(.*)/${1:/downcase}/} = await ${1:ModelName}.findByPk(id);",
      "    ",
      "    if (!${1/(.*)/${1:/downcase}/}) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error fetching ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Create new ${1/(.*)/${1:/downcase}/}",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const create${1:ModelName} = async (req, res, next) => {",
      "  try {",
      "    const ${1/(.*)/${1:/downcase}/}Data = req.body;",
      "    ",
      "    const ${1/(.*)/${1:/downcase}/} = await ${1:ModelName}.create(${1/(.*)/${1:/downcase}/}Data);",
      "    ",
      "    res.status(201).json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error creating ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Update ${1/(.*)/${1:/downcase}/} by ID",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const update${1:ModelName} = async (req, res, next) => {",
      "  try {",
      "    const { id } = req.params;",
      "    const updateData = req.body;",
      "    ",
      "    const [affectedRows] = await ${1:ModelName}.update(updateData, {",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    const updated${1:ModelName} = await ${1:ModelName}.findByPk(id);",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: updated${1:ModelName}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error updating ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Delete ${1/(.*)/${1:/downcase}/} by ID",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const delete${1:ModelName} = async (req, res, next) => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const affectedRows = await ${1:ModelName}.destroy({",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    res.status(204).send();",
      "  } catch (error) {",
      "    logger.error('Error deleting ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "module.exports = {",
      "  getAll${1:ModelName}s,",
      "  get${1:ModelName}ById,",
      "  create${1:ModelName},",
      "  update${1:ModelName},",
      "  delete${1:ModelName}",
      "};"
    ],
    "description": "Complete REST controller with CRUD operations"
  },
  "REST Express Route": {
    "prefix": "rest-route",
    "body": [
      "/**",
      " * ${1:Resource} Routes",
      " * ",
      " * Defines HTTP routes for ${1:Resource} resources",
      " * @author ${2:Author}",
      " */",
      "",
      "const express = require('express');",
      "const { validateRequest, authenticate, authorize } = require('../middlewares');",
      "const ${1/(.*)/${1:/downcase}/}Controller = require('../controllers/${1/(.*)/${1:/downcase}/}Controller');",
      "const ${1/(.*)/${1:/downcase}/}Schemas = require('../schemas/${1/(.*)/${1:/downcase}/}Schemas');",
      "",
      "const router = express.Router();",
      "",
      "// Apply authentication to all routes",
      "router.use(authenticate);",
      "",
      "/**",
      " * @swagger",
      " * /api/${1/(.*)/${1:/downcase}/}s:",
      " *   get:",
      " *     summary: Get all ${1/(.*)/${1:/downcase}/}s",
      " *     tags: [${1:Resource}]",
      " *     parameters:",
      " *       - in: query",
      " *         name: page",
      " *         schema:",
      " *           type: integer",
      " *           default: 1",
      " *       - in: query",
      " *         name: limit",
      " *         schema:",
      " *           type: integer",
      " *           default: 10",
      " *     responses:",
      " *       200:",
      " *         description: List of ${1/(.*)/${1:/downcase}/}s",
      " */",
      "router.get('/',",
      "  authorize(['admin', 'user']),",
      "  ${1/(.*)/${1:/downcase}/}Controller.getAll${1:Resource}s",
      ");",
      "",
      "/**",
      " * @swagger",
      " * /api/${1/(.*)/${1:/downcase}/}s/{id}:",
      " *   get:",
      " *     summary: Get ${1/(.*)/${1:/downcase}/} by ID",
      " *     tags: [${1:Resource}]",
      " *     parameters:",
      " *       - in: path",
      " *         name: id",
      " *         required: true",
      " *         schema:",
      " *           type: integer",
      " *     responses:",
      " *       200:",
      " *         description: ${1:Resource} details",
      " *       404:",
      " *         description: ${1:Resource} not found",
      " */",
      "router.get('/:id',",
      "  authorize(['admin', 'user']),",
      "  ${1/(.*)/${1:/downcase}/}Controller.get${1:Resource}ById",
      ");",
      "",
      "/**",
      " * @swagger",
      " * /api/${1/(.*)/${1:/downcase}/}s:",
      " *   post:",
      " *     summary: Create new ${1/(.*)/${1:/downcase}/}",
      " *     tags: [${1:Resource}]",
      " *     requestBody:",
      " *       required: true",
      " *       content:",
      " *         application/json:",
      " *           schema:",
      " *             $ref: '#/components/schemas/${1:Resource}'",
      " *     responses:",
      " *       201:",
      " *         description: ${1:Resource} created successfully",
      " *       400:",
      " *         description: Validation error",
      " */",
      "router.post('/',",
      "  authorize(['admin']),",
      "  validateRequest(${1/(.*)/${1:/downcase}/}Schemas.create),",
      "  ${1/(.*)/${1:/downcase}/}Controller.create${1:Resource}",
      ");",
      "",
      "/**",
      " * @swagger",
      " * /api/${1/(.*)/${1:/downcase}/}s/{id}:",
      " *   put:",
      " *     summary: Update ${1/(.*)/${1:/downcase}/}",
      " *     tags: [${1:Resource}]",
      " *     parameters:",
      " *       - in: path",
      " *         name: id",
      " *         required: true",
      " *         schema:",
      " *           type: integer",
      " *     requestBody:",
      " *       required: true",
      " *       content:",
      " *         application/json:",
      " *           schema:",
      " *             $ref: '#/components/schemas/${1:Resource}'",
      " *     responses:",
      " *       200:",
      " *         description: ${1:Resource} updated successfully",
      " *       404:",
      " *         description: ${1:Resource} not found",
      " */",
      "router.put('/:id',",
      "  authorize(['admin']),",
      "  validateRequest(${1/(.*)/${1:/downcase}/}Schemas.update),",
      "  ${1/(.*)/${1:/downcase}/}Controller.update${1:Resource}",
      ");",
      "",
      "/**",
      " * @swagger",
      " * /api/${1/(.*)/${1:/downcase}/}s/{id}:",
      " *   delete:",
      " *     summary: Delete ${1/(.*)/${1:/downcase}/}",
      " *     tags: [${1:Resource}]",
      " *     parameters:",
      " *       - in: path",
      " *         name: id",
      " *         required: true",
      " *         schema:",
      " *           type: integer",
      " *     responses:",
      " *       204:",
      " *         description: ${1:Resource} deleted successfully",
      " *       404:",
      " *         description: ${1:Resource} not found",
      " */",
      "router.delete('/:id',",
      "  authorize(['admin']),",
      "  ${1/(.*)/${1:/downcase}/}Controller.delete${1:Resource}",
      ");",
      "",
      "module.exports = router;"
    ],
    "description": "Complete REST route with Swagger documentation"
  },
  "Sequelize Model": {
    "prefix": "sequelize-model",
    "body": [
      "/**",
      " * ${1:ModelName} Model",
      " * ",
      " * Sequelize model definition for ${1:ModelName}",
      " * @author ${2:Author}",
      " */",
      "",
      "const { DataTypes } = require('sequelize');",
      "",
      "module.exports = (sequelize) => {",
      "  const ${1:ModelName} = sequelize.define('${1:ModelName}', {",
      "    id: {",
      "      type: DataTypes.INTEGER,",
      "      primaryKey: true,",
      "      autoIncrement: true",
      "    },",
      "    ${3:name}: {",
      "      type: DataTypes.STRING(255),",
      "      allowNull: false,",
      "      validate: {",
      "        notEmpty: true,",
      "        len: [1, 255]",
      "      }",
      "    },",
      "    ${4:description}: {",
      "      type: DataTypes.TEXT,",
      "      allowNull: true",
      "    },",
      "    isActive: {",
      "      type: DataTypes.BOOLEAN,",
      "      defaultValue: true",
      "    }",
      "  }, {",
      "    tableName: '${1/(.*)/${1:/downcase}/}s',",
      "    timestamps: true,",
      "    paranoid: true, // Soft delete",
      "    underscored: true, // Use snake_case for column names",
      "    indexes: [",
      "      {",
      "        fields: ['${3:name}']",
      "      },",
      "      {",
      "        fields: ['is_active']",
      "      }",
      "    ],",
      "    hooks: {",
      "      beforeCreate: async (instance) => {",
      "        // Add any pre-creation logic here",
      "        ${5:// Example: instance.slug = instance.name.toLowerCase().replace(/\\s+/g, '-');}",
      "      },",
      "      beforeUpdate: async (instance) => {",
      "        // Add any pre-update logic here",
      "      }",
      "    }",
      "  });",
      "",
      "  // Define associations",
      "  ${1:ModelName}.associate = (models) => {",
      "    // Example associations:",
      "    // ${1:ModelName}.belongsTo(models.User, { foreignKey: 'userId', as: 'user' });",
      "    // ${1:ModelName}.hasMany(models.Item, { foreignKey: '${1/(.*)/${1:/downcase}/}Id', as: 'items' });",
      "    ${6}",
      "  };",
      "",
      "  // Instance methods",
      "  ${1:ModelName}.prototype.toJSON = function() {",
      "    const values = { ...this.get() };",
      "    // Remove sensitive fields if any",
      "    return values;",
      "  };",
      "",
      "  // Class methods",
      "  ${1:ModelName}.findActive = function() {",
      "    return this.findAll({",
      "      where: { isActive: true }",
      "    });",
      "  };",
      "",
      "  return ${1:ModelName};",
      "};"
    ],
    "description": "Complete Sequelize model with associations and methods"
  },
  "Express Middleware": {
    "prefix": "express-middleware",
    "body": [
      "/**",
      " * ${1:MiddlewareName} Middleware",
      " * ",
      " * ${2:Description of what this middleware does}",
      " * @author ${3:Author}",
      " */",
      "",
      "const logger = require('../utils/logger');",
      "",
      "/**",
      " * ${1:MiddlewareName} middleware function",
      " * @param {Object} req - Express request object",
      " * @param {Object} res - Express response object",
      " * @param {Function} next - Express next middleware function",
      " */",
      "const ${1/(.*)/${1:/downcase}/} = (req, res, next) => {",
      "  try {",
      "    // Middleware logic here",
      "    ${4:// Example: req.startTime = Date.now();}",
      "    ",
      "    // Continue to next middleware",
      "    next();",
      "  } catch (error) {",
      "    logger.error('${1:MiddlewareName} middleware error:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "module.exports = ${1/(.*)/${1:/downcase}/};"
    ],
    "description": "Express middleware function template"
  },
  "Jest Test Suite": {
    "prefix": "jest-test",
    "body": [
      "/**",
      " * ${1:ComponentName} Tests",
      " * ",
      " * Test suite for ${1:ComponentName}",
      " * @author ${2:Author}",
      " */",
      "",
      "const request = require('supertest');",
      "const app = require('../app');",
      "const { ${3:ModelName} } = require('../models');",
      "",
      "describe('${1:ComponentName}', () => {",
      "  beforeAll(async () => {",
      "    // Setup before all tests",
      "    ${4:// await setupTestDatabase();}",
      "  });",
      "",
      "  afterAll(async () => {",
      "    // Cleanup after all tests",
      "    ${5:// await cleanupTestDatabase();}",
      "  });",
      "",
      "  beforeEach(async () => {",
      "    // Setup before each test",
      "    ${6:// await seedTestData();}",
      "  });",
      "",
      "  afterEach(async () => {",
      "    // Cleanup after each test",
      "    ${7:// await clearTestData();}",
      "  });",
      "",
      "  describe('${8:Method/Feature}', () => {",
      "    it('should ${9:expected behavior}', async () => {",
      "      // Arrange",
      "      ${10:const testData = { name: 'Test Item' };}",
      "",
      "      // Act",
      "      ${11:const result = await someFunction(testData);}",
      "",
      "      // Assert",
      "      ${12:expect(result).toBeDefined();}",
      "      ${13:expect(result.name).toBe('Test Item');}",
      "    });",
      "",
      "    it('should handle error cases', async () => {",
      "      // Test error scenarios",
      "      ${14:await expect(someFunction(null)).rejects.toThrow();}",
      "    });",
      "  });",
      "",
      "  describe('API Endpoints', () => {",
      "    it('GET /${15:endpoint} should return 200', async () => {",
      "      const response = await request(app)",
      "        .get('/${15:endpoint}')",
      "        .expect(200);",
      "",
      "      expect(response.body.success).toBe(true);",
      "      expect(response.body.data).toBeDefined();",
      "    });",
      "",
      "    it('POST /${15:endpoint} should create resource', async () => {",
      "      const testData = {",
      "        ${16:name: 'Test Resource'}",
      "      };",
      "",
      "      const response = await request(app)",
      "        .post('/${15:endpoint}')",
      "        .send(testData)",
      "        .expect(201);",
      "",
      "      expect(response.body.success).toBe(true);",
      "      expect(response.body.data.${16/(.*):\s*(.*)/\\1/}).toBe(testData.${16/(.*):\s*(.*)/\\1/});",
      "    });",
      "  });",
      "});"
    ],
    "description": "Complete Jest test suite template"
  },
  "Validation Schema": {
    "prefix": "joi-schema",
    "body": [
      "/**",
      " * ${1:ResourceName} Validation Schemas",
      " * ",
      " * Joi validation schemas for ${1:ResourceName} operations",
      " * @author ${2:Author}",
      " */",
      "",
      "const Joi = require('joi');",
      "",
      "const ${1/(.*)/${1:/downcase}/}Schemas = {",
      "  // Create ${1/(.*)/${1:/downcase}/} schema",
      "  create: Joi.object({",
      "    ${3:name}: Joi.string()",
      "      .min(1)",
      "      .max(255)",
      "      .required()",
      "      .messages({",
      "        'string.base': '${3:Name} must be a string',",
      "        'string.empty': '${3:Name} cannot be empty',",
      "        'string.min': '${3:Name} must be at least 1 character',",
      "        'string.max': '${3:Name} must not exceed 255 characters',",
      "        'any.required': '${3:Name} is required'",
      "      }),",
      "    ${4:email}: Joi.string()",
      "      .email()",
      "      .required()",
      "      .messages({",
      "        'string.email': 'Please provide a valid email address',",
      "        'any.required': 'Email is required'",
      "      }),",
      "    ${5:age}: Joi.number()",
      "      .integer()",
      "      .min(0)",
      "      .max(150)",
      "      .optional()",
      "      .messages({",
      "        'number.base': 'Age must be a number',",
      "        'number.integer': 'Age must be an integer',",
      "        'number.min': 'Age must be at least 0',",
      "        'number.max': 'Age must not exceed 150'",
      "      })",
      "  }),",
      "",
      "  // Update ${1/(.*)/${1:/downcase}/} schema (all fields optional)",
      "  update: Joi.object({",
      "    ${3:name}: Joi.string()",
      "      .min(1)",
      "      .max(255)",
      "      .optional(),",
      "    ${4:email}: Joi.string()",
      "      .email()",
      "      .optional(),",
      "    ${5:age}: Joi.number()",
      "      .integer()",
      "      .min(0)",
      "      .max(150)",
      "      .optional()",
      "  }),",
      "",
      "  // Query parameters schema",
      "  query: Joi.object({",
      "    page: Joi.number()",
      "      .integer()",
      "      .min(1)",
      "      .default(1)",
      "      .optional(),",
      "    limit: Joi.number()",
      "      .integer()",
      "      .min(1)",
      "      .max(100)",
      "      .default(10)",
      "      .optional(),",
      "    sort: Joi.string()",
      "      .valid('${3:name}', '${4:email}', 'createdAt', 'updatedAt')",
      "      .default('createdAt')",
      "      .optional(),",
      "    order: Joi.string()",
      "      .valid('ASC', 'DESC')",
      "      .default('DESC')",
      "      .optional(),",
      "    search: Joi.string()",
      "      .max(255)",
      "      .optional()",
      "  }),",
      "",
      "  // ID parameter schema",
      "  params: Joi.object({",
      "    id: Joi.number()",
      "      .integer()",
      "      .positive()",
      "      .required()",
      "      .messages({",
      "        'number.base': 'ID must be a number',",
      "        'number.integer': 'ID must be an integer',",
      "        'number.positive': 'ID must be positive',",
      "        'any.required': 'ID is required'",
      "      })",
      "  })",
      "};",
      "",
      "module.exports = ${1/(.*)/${1:/downcase}/}Schemas;"
    ],
    "description": "Complete Joi validation schemas for CRUD operations"
  }
}
