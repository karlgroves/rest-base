{
  "TypeScript REST Controller": {
    "prefix": "ts-rest-controller",
    "body": [
      "/**",
      " * ${1:ModelName} Controller",
      " * ",
      " * Handles HTTP requests for ${1:ModelName} resources",
      " * @author ${2:Author}",
      " */",
      "",
      "import { Request, Response, NextFunction } from 'express';",
      "import { ${1:ModelName} } from '../models';",
      "import { ValidationError, NotFoundError } from '../utils/errors';",
      "import logger from '../utils/logger';",
      "",
      "interface ${1:ModelName}Query {",
      "  page?: number;",
      "  limit?: number;",
      "  sort?: string;",
      "  order?: 'ASC' | 'DESC';",
      "}",
      "",
      "interface ${1:ModelName}Body {",
      "  ${3:name}: string;",
      "  ${4:description}?: string;",
      "  isActive?: boolean;",
      "}",
      "",
      "/**",
      " * Get all ${1/(.*)/${1:/downcase}/} records",
      " */",
      "export const getAll${1:ModelName}s = async (",
      "  req: Request<{}, any, any, ${1:ModelName}Query>,",
      "  res: Response,",
      "  next: NextFunction",
      "): Promise<void> => {",
      "  try {",
      "    const { page = 1, limit = 10, sort = 'createdAt', order = 'DESC' } = req.query;",
      "    ",
      "    const offset = (page - 1) * limit;",
      "    ",
      "    const { rows: ${1/(.*)/${1:/downcase}/}s, count } = await ${1:ModelName}.findAndCountAll({",
      "      offset: Number(offset),",
      "      limit: Number(limit),",
      "      order: [[sort, order]]",
      "    });",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}s,",
      "      pagination: {",
      "        page: Number(page),",
      "        limit: Number(limit),",
      "        total: count,",
      "        totalPages: Math.ceil(count / limit)",
      "      }",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error fetching ${1/(.*)/${1:/downcase}/}s:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Get ${1/(.*)/${1:/downcase}/} by ID",
      " */",
      "export const get${1:ModelName}ById = async (",
      "  req: Request<{ id: string }>,",
      "  res: Response,",
      "  next: NextFunction",
      "): Promise<void> => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const ${1/(.*)/${1:/downcase}/} = await ${1:ModelName}.findByPk(id);",
      "    ",
      "    if (!${1/(.*)/${1:/downcase}/}) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error fetching ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Create new ${1/(.*)/${1:/downcase}/}",
      " */",
      "export const create${1:ModelName} = async (",
      "  req: Request<{}, any, ${1:ModelName}Body>,",
      "  res: Response,",
      "  next: NextFunction",
      "): Promise<void> => {",
      "  try {",
      "    const ${1/(.*)/${1:/downcase}/}Data = req.body;",
      "    ",
      "    const ${1/(.*)/${1:/downcase}/} = await ${1:ModelName}.create(${1/(.*)/${1:/downcase}/}Data);",
      "    ",
      "    res.status(201).json({",
      "      success: true,",
      "      data: ${1/(.*)/${1:/downcase}/}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error creating ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Update ${1/(.*)/${1:/downcase}/} by ID",
      " */",
      "export const update${1:ModelName} = async (",
      "  req: Request<{ id: string }, any, Partial<${1:ModelName}Body>>,",
      "  res: Response,",
      "  next: NextFunction",
      "): Promise<void> => {",
      "  try {",
      "    const { id } = req.params;",
      "    const updateData = req.body;",
      "    ",
      "    const [affectedRows] = await ${1:ModelName}.update(updateData, {",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    const updated${1:ModelName} = await ${1:ModelName}.findByPk(id);",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: updated${1:ModelName}",
      "    });",
      "  } catch (error) {",
      "    logger.error('Error updating ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};",
      "",
      "/**",
      " * Delete ${1/(.*)/${1:/downcase}/} by ID",
      " */",
      "export const delete${1:ModelName} = async (",
      "  req: Request<{ id: string }>,",
      "  res: Response,",
      "  next: NextFunction",
      "): Promise<void> => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const affectedRows = await ${1:ModelName}.destroy({",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${1:ModelName} not found');",
      "    }",
      "    ",
      "    res.status(204).send();",
      "  } catch (error) {",
      "    logger.error('Error deleting ${1/(.*)/${1:/downcase}/}:', error);",
      "    next(error);",
      "  }",
      "};"
    ],
    "description": "TypeScript REST controller with proper typing"
  },
  "TypeScript Interface": {
    "prefix": "ts-interface",
    "body": [
      "/**",
      " * ${1:InterfaceName} Interface",
      " * ",
      " * ${2:Description of the interface}",
      " * @author ${3:Author}",
      " */",
      "",
      "export interface ${1:InterfaceName} {",
      "  id: number;",
      "  ${4:name}: string;",
      "  ${5:description}?: string;",
      "  isActive: boolean;",
      "  createdAt: Date;",
      "  updatedAt: Date;",
      "  deletedAt?: Date;",
      "}",
      "",
      "export interface ${1:InterfaceName}CreateRequest {",
      "  ${4:name}: string;",
      "  ${5:description}?: string;",
      "  isActive?: boolean;",
      "}",
      "",
      "export interface ${1:InterfaceName}UpdateRequest {",
      "  ${4:name}?: string;",
      "  ${5:description}?: string;",
      "  isActive?: boolean;",
      "}",
      "",
      "export interface ${1:InterfaceName}Query {",
      "  page?: number;",
      "  limit?: number;",
      "  sort?: keyof ${1:InterfaceName};",
      "  order?: 'ASC' | 'DESC';",
      "  search?: string;",
      "}"
    ],
    "description": "TypeScript interface definitions for API resources"
  },
  "TypeScript Service": {
    "prefix": "ts-service",
    "body": [
      "/**",
      " * ${1:ServiceName} Service",
      " * ",
      " * Business logic for ${1:ServiceName} operations",
      " * @author ${2:Author}",
      " */",
      "",
      "import { ${3:ModelName} } from '../models';",
      "import { NotFoundError, ValidationError } from '../utils/errors';",
      "import logger from '../utils/logger';",
      "",
      "export interface ${3:ModelName}Data {",
      "  ${4:name}: string;",
      "  ${5:description}?: string;",
      "  isActive?: boolean;",
      "}",
      "",
      "export interface ${3:ModelName}Query {",
      "  page?: number;",
      "  limit?: number;",
      "  sort?: string;",
      "  order?: 'ASC' | 'DESC';",
      "  search?: string;",
      "}",
      "",
      "export class ${1:ServiceName}Service {",
      "  /**",
      "   * Get all ${3/(.*)/${1:/downcase}/} records with pagination",
      "   */",
      "  static async getAll(query: ${3:ModelName}Query = {}) {",
      "    const { page = 1, limit = 10, sort = 'createdAt', order = 'DESC', search } = query;",
      "    ",
      "    const offset = (page - 1) * limit;",
      "    const whereClause: any = {};",
      "    ",
      "    if (search) {",
      "      whereClause.${4:name} = {",
      "        [Op.iLike]: `%${search}%`",
      "      };",
      "    }",
      "    ",
      "    const { rows, count } = await ${3:ModelName}.findAndCountAll({",
      "      where: whereClause,",
      "      offset,",
      "      limit,",
      "      order: [[sort, order]]",
      "    });",
      "    ",
      "    return {",
      "      data: rows,",
      "      pagination: {",
      "        page,",
      "        limit,",
      "        total: count,",
      "        totalPages: Math.ceil(count / limit)",
      "      }",
      "    };",
      "  }",
      "",
      "  /**",
      "   * Get ${3/(.*)/${1:/downcase}/} by ID",
      "   */",
      "  static async getById(id: number) {",
      "    const ${3/(.*)/${1:/downcase}/} = await ${3:ModelName}.findByPk(id);",
      "    ",
      "    if (!${3/(.*)/${1:/downcase}/}) {",
      "      throw new NotFoundError('${3:ModelName} not found');",
      "    }",
      "    ",
      "    return ${3/(.*)/${1:/downcase}/};",
      "  }",
      "",
      "  /**",
      "   * Create new ${3/(.*)/${1:/downcase}/}",
      "   */",
      "  static async create(data: ${3:ModelName}Data) {",
      "    try {",
      "      const ${3/(.*)/${1:/downcase}/} = await ${3:ModelName}.create(data);",
      "      logger.info(`${3:ModelName} created with ID: ${${3/(.*)/${1:/downcase}/}.id}`);",
      "      return ${3/(.*)/${1:/downcase}/};",
      "    } catch (error) {",
      "      logger.error('Error creating ${3/(.*)/${1:/downcase}/}:', error);",
      "      throw new ValidationError('Failed to create ${3/(.*)/${1:/downcase}/}');",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Update ${3/(.*)/${1:/downcase}/} by ID",
      "   */",
      "  static async update(id: number, data: Partial<${3:ModelName}Data>) {",
      "    const [affectedRows] = await ${3:ModelName}.update(data, {",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${3:ModelName} not found');",
      "    }",
      "    ",
      "    const updated${3:ModelName} = await ${3:ModelName}.findByPk(id);",
      "    logger.info(`${3:ModelName} updated with ID: ${id}`);",
      "    ",
      "    return updated${3:ModelName};",
      "  }",
      "",
      "  /**",
      "   * Delete ${3/(.*)/${1:/downcase}/} by ID",
      "   */",
      "  static async delete(id: number) {",
      "    const affectedRows = await ${3:ModelName}.destroy({",
      "      where: { id }",
      "    });",
      "    ",
      "    if (affectedRows === 0) {",
      "      throw new NotFoundError('${3:ModelName} not found');",
      "    }",
      "    ",
      "    logger.info(`${3:ModelName} deleted with ID: ${id}`);",
      "    return true;",
      "  }",
      "",
      "  /**",
      "   * Check if ${3/(.*)/${1:/downcase}/} exists",
      "   */",
      "  static async exists(id: number): Promise<boolean> {",
      "    const count = await ${3:ModelName}.count({",
      "      where: { id }",
      "    });",
      "    ",
      "    return count > 0;",
      "  }",
      "}"
    ],
    "description": "TypeScript service class with business logic"
  }
}
